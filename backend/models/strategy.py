"""
Pydantic models for custom trading strategies
"""
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional, Union, Literal
from datetime import datetime, date
import uuid


class DataRequirement(BaseModel):
    """Defines what data is needed for strategy evaluation"""
    source: Literal["fmp", "reddit", "calculated", "user_portfolio"]
    data_type: str  # e.g., "insider_trading", "price_history", "rsi"
    parameters: Dict[str, Any] = Field(default_factory=dict)  # e.g., {"period": 14, "ticker": "$SYMBOL"}


class Condition(BaseModel):
    """A single condition for entry/exit logic"""
    field: str  # e.g., "rsi", "insider_buy_amount", "price_change_pct"
    operator: Literal["gt", "lt", "gte", "lte", "eq", "between", "in"]
    value: Union[float, int, List[Any]]
    description: Optional[str] = None  # Human-readable explanation


class RiskParameters(BaseModel):
    """Risk management settings for a strategy"""
    stop_loss_pct: Optional[float] = Field(None, description="Stop loss as percentage from entry")
    take_profit_pct: Optional[float] = Field(None, description="Take profit target as percentage")
    max_hold_days: Optional[int] = Field(None, description="Maximum days to hold position")
    position_size_pct: float = Field(5.0, description="Position size as % of portfolio")
    max_positions: int = Field(5, description="Maximum concurrent positions")


class TradingStrategy(BaseModel):
    """Complete definition of a trading strategy"""
    id: Optional[str] = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    name: str
    description: str
    natural_language_input: str  # Original user input
    timeframe: Literal["short_term", "medium_term", "long_term"]
    
    # Data requirements
    data_requirements: List[DataRequirement]
    
    # Entry logic
    entry_conditions: List[Condition]
    entry_logic: Literal["AND", "OR"] = "AND"  # How to combine conditions
    
    # Exit logic
    exit_conditions: List[Condition]
    exit_logic: Literal["AND", "OR"] = "OR"
    
    # Risk management
    risk_parameters: RiskParameters
    
    # Universe of stocks to scan
    stock_universe: Optional[List[str]] = None  # If None, use S&P 500
    
    # Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    is_active: bool = True
    
    class Config:
        json_schema_extra = {
            "example": {
                "user_id": "user123",
                "name": "Insider + RSI Oversold",
                "description": "Buy when insiders are buying and stock is oversold",
                "natural_language_input": "Buy stocks when 3+ insiders buy more than $500K total in the last 30 days AND RSI is below 30",
                "timeframe": "short_term",
                "data_requirements": [
                    {
                        "source": "fmp",
                        "data_type": "insider_trading",
                        "parameters": {"days": 30}
                    },
                    {
                        "source": "calculated",
                        "data_type": "rsi",
                        "parameters": {"period": 14}
                    }
                ],
                "entry_conditions": [
                    {
                        "field": "insider_buy_count",
                        "operator": "gte",
                        "value": 3,
                        "description": "At least 3 insider buys"
                    },
                    {
                        "field": "insider_buy_amount",
                        "operator": "gt",
                        "value": 500000,
                        "description": "Total insider buying over $500K"
                    },
                    {
                        "field": "rsi",
                        "operator": "lt",
                        "value": 30,
                        "description": "RSI below 30 (oversold)"
                    }
                ],
                "entry_logic": "AND",
                "exit_conditions": [
                    {
                        "field": "rsi",
                        "operator": "gt",
                        "value": 70,
                        "description": "RSI above 70 (overbought)"
                    }
                ],
                "exit_logic": "OR",
                "risk_parameters": {
                    "stop_loss_pct": 12.0,
                    "take_profit_pct": 25.0,
                    "max_hold_days": 60,
                    "position_size_pct": 5.0,
                    "max_positions": 5
                }
            }
        }


class StrategySignal(BaseModel):
    """A trade signal generated by a strategy"""
    signal_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: str
    ticker: str
    signal_type: Literal["entry", "exit"]
    generated_at: datetime = Field(default_factory=datetime.utcnow)
    price_at_signal: float
    confidence_score: float = Field(..., ge=0, le=100)  # 0-100
    reasoning: str  # Why this signal was generated
    data_snapshot: Dict[str, Any]  # All data used for decision
    
    # User interaction tracking
    user_acted: bool = False
    outcome: Optional[Dict[str, Any]] = None  # If user took trade, track result


class BacktestTrade(BaseModel):
    """A single trade from a backtest"""
    ticker: str
    entry_date: date
    entry_price: float
    exit_date: date
    exit_price: float
    shares: int
    pnl: float
    pnl_pct: float
    days_held: int
    exit_reason: Literal["signal", "stop_loss", "take_profit", "max_hold", "backtest_end"]


class StrategyBacktest(BaseModel):
    """Results from backtesting a strategy"""
    backtest_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: str
    start_date: date
    end_date: date
    initial_capital: float
    
    # Performance metrics
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    
    total_return_pct: float
    total_return_dollars: float
    final_equity: float
    
    avg_win_pct: float
    avg_loss_pct: float
    profit_factor: float  # avg_win / avg_loss
    
    max_drawdown_pct: float
    sharpe_ratio: Optional[float] = None
    
    # Best and worst trades
    best_trade: Optional[BacktestTrade] = None
    worst_trade: Optional[BacktestTrade] = None
    
    # Detailed trades
    trades: List[BacktestTrade] = []
    
    # Time series data for charts
    equity_curve: List[Dict[str, Any]] = []
    
    # Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow)


class StrategyPerformance(BaseModel):
    """Live tracking of strategy performance"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: str
    user_id: str
    
    # Live signals tracked
    signals_generated: int = 0
    signals_acted_on: int = 0
    
    # If user took the trades
    actual_trades: int = 0
    actual_wins: int = 0
    actual_losses: int = 0
    actual_return_pct: float = 0.0
    
    # Hypothetical (if they took all signals)
    hypothetical_trades: int = 0
    hypothetical_return_pct: float = 0.0
    
    last_signal_date: Optional[datetime] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


class StrategyComparison(BaseModel):
    """Comparison data for multiple strategies"""
    strategy_id: str
    strategy_name: str
    timeframe: str
    signals_generated: int
    win_rate: Optional[float] = None
    actual_return_pct: float
    hypothetical_return_pct: float
    last_signal: Optional[datetime] = None
    is_active: bool

