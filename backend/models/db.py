"""
SQLAlchemy database models
"""
from sqlalchemy import Column, String, DateTime, Text, Boolean, Integer
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.sql import func
from database import Base


class SnapTradeUser(Base):
    """
    Stores SnapTrade user connections per user
    
    SnapTrade handles OAuth authentication, but we need to store the userSecret
    that SnapTrade generates for each user so we can make API calls on their behalf.
    
    SECURITY:
    - userSecret is sensitive and should be treated like a password
    - OAuth flow handled by SnapTrade
    - We store user_id (Supabase UUID), userSecret, and account references
    """
    __tablename__ = "snaptrade_users"
    
    # Primary key (Supabase user ID from OAuth)
    user_id = Column(String, primary_key=True, index=True)
    
    # SnapTrade user ID (returned after registering user with SnapTrade)
    snaptrade_user_id = Column(String, unique=True, nullable=False, index=True)
    
    # SnapTrade user secret (generated by SnapTrade, needed for all API calls)
    snaptrade_user_secret = Column(Text, nullable=False)
    
    # SnapTrade account IDs (JSON array of connected account IDs)
    # Stored as comma-separated string for simplicity
    connected_account_ids = Column(Text, nullable=True)
    
    # Connection metadata
    is_connected = Column(Boolean, default=False, nullable=False)
    brokerage_name = Column(String, nullable=True)  # e.g., "Robinhood", "TD Ameritrade"
    
    # Session tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_activity = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<SnapTradeUser(user_id='{self.user_id}', snaptrade_user_id='{self.snaptrade_user_id}', is_connected={self.is_connected})>"


class Chat(Base):
    """
    Stores chat session metadata
    
    Each chat represents a conversation thread between the user and the AI.
    Users can have multiple chats, and can switch between them.
    """
    __tablename__ = "chats"
    
    # Primary key
    chat_id = Column(String, primary_key=True, index=True)
    
    # User ID (links to the same user_id used in SnapTradeUser)
    user_id = Column(String, nullable=False, index=True)
    
    # Chat metadata
    title = Column(String, nullable=True)  # Auto-generated or user-set title
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<Chat(chat_id='{self.chat_id}', user_id='{self.user_id}', title='{self.title}')>"


class ChatMessage(Base):
    """
    Stores individual chat messages within a chat session (OpenAI format)
    
    Each message belongs to a chat and has a role (user, assistant, or tool).
    Messages are ordered by their sequence number within the chat.
    
    Message types (matching OpenAI API format):
    - user: User input messages (content field only)
    - assistant: AI responses (content field, optionally tool_calls JSONB)
    - tool: Tool/function results (content field, tool_call_id, name, and resource_id FK)
    """
    __tablename__ = "chat_messages"
    
    # Primary key (auto-increment)
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign key to chat
    chat_id = Column(String, nullable=False, index=True)
    
    # Message content
    role = Column(String, nullable=False)  # 'user', 'assistant', or 'tool'
    content = Column(Text, nullable=False)
    
    # Sequence number within the chat (for ordering)
    sequence = Column(Integer, nullable=False)
    
    # Tool call data (for assistant messages that call tools)
    tool_calls = Column(JSONB, nullable=True)
    
    # Tool result metadata (for tool role messages)
    tool_call_id = Column(String, nullable=True, index=True)
    name = Column(String, nullable=True)  # Tool/function name
    
    # Performance metrics (for assistant messages)
    latency_ms = Column(Integer, nullable=True)  # Response time in milliseconds
    
    # Foreign key to resource (for tool result messages)
    resource_id = Column(String, nullable=True, index=True)
    
    # Timestamp
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<ChatMessage(id={self.id}, chat_id='{self.chat_id}', role='{self.role}', seq={self.sequence})>"


class Resource(Base):
    """
    Stores function call results as resources that users can browse
    
    Resources contain the full data from tool/function executions.
    ChatMessages can optionally reference a resource via resource_id.
    """
    __tablename__ = "resources"
    
    # Primary key
    id = Column(String, primary_key=True, index=True)
    
    # Links to chat and user (for querying all resources in a chat/user)
    chat_id = Column(String, nullable=False, index=True)
    user_id = Column(String, nullable=False, index=True)
    
    # Tool call information
    tool_name = Column(String, nullable=False)
    
    # Resource metadata
    resource_type = Column(String, nullable=False)  # 'portfolio', 'insider_trades', 'reddit_trends', etc.
    title = Column(String, nullable=False)
    
    # Resource data (stored as JSONB for efficient querying)
    data = Column(JSONB, nullable=False)
    resource_metadata = Column(JSONB, nullable=True)  # Additional metadata like parameters
    
    # Timestamp
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)
    
    def __repr__(self):
        return f"<Resource(id='{self.id}', type='{self.resource_type}', tool='{self.tool_name}')>"

