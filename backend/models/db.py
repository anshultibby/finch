"""
SQLAlchemy database models
"""
from sqlalchemy import Column, String, DateTime, Text, Boolean, Integer, Numeric, Date, ARRAY, Float
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.sql import func
from database import Base
import uuid


class SnapTradeUser(Base):
    """
    Stores SnapTrade user connections per user
    
    SnapTrade handles OAuth authentication, but we need to store the userSecret
    that SnapTrade generates for each user so we can make API calls on their behalf.
    
    SECURITY:
    - userSecret is sensitive and should be treated like a password
    - OAuth flow handled by SnapTrade
    - We store user_id (Supabase UUID), userSecret, and account references
    """
    __tablename__ = "snaptrade_users"
    
    # Primary key (Supabase user ID from OAuth)
    user_id = Column(String, primary_key=True, index=True)
    
    # SnapTrade user ID (returned after registering user with SnapTrade)
    snaptrade_user_id = Column(String, unique=True, nullable=False, index=True)
    
    # SnapTrade user secret (generated by SnapTrade, needed for all API calls)
    snaptrade_user_secret = Column(Text, nullable=False)
    
    # SnapTrade account IDs (JSON array of connected account IDs)
    # Stored as comma-separated string for simplicity
    connected_account_ids = Column(Text, nullable=True)
    
    # Connection metadata
    is_connected = Column(Boolean, default=False, nullable=False)
    brokerage_name = Column(String, nullable=True)  # e.g., "Robinhood", "TD Ameritrade"
    
    # Session tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_activity = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<SnapTradeUser(user_id='{self.user_id}', snaptrade_user_id='{self.snaptrade_user_id}', is_connected={self.is_connected})>"


class Chat(Base):
    """
    Stores chat session metadata
    
    Each chat represents a conversation thread between the user and the AI.
    Users can have multiple chats, and can switch between them.
    """
    __tablename__ = "chats"
    
    # Primary key
    chat_id = Column(String, primary_key=True, index=True)
    
    # User ID (links to the same user_id used in SnapTradeUser)
    user_id = Column(String, nullable=False, index=True)
    
    # Chat metadata
    title = Column(String, nullable=True)  # Auto-generated or user-set title
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<Chat(chat_id='{self.chat_id}', user_id='{self.user_id}', title='{self.title}')>"


class ChatMessage(Base):
    """
    Stores individual chat messages within a chat session (OpenAI format)
    
    Each message belongs to a chat and has a role (user, assistant, or tool).
    Messages are ordered by their sequence number within the chat.
    
    Message types (matching OpenAI API format):
    - user: User input messages (content field only)
    - assistant: AI responses (content field, optionally tool_calls JSONB)
    - tool: Tool/function results (content field, tool_call_id, name, and resource_id FK)
    """
    __tablename__ = "chat_messages"
    
    # Primary key (auto-increment)
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign key to chat
    chat_id = Column(String, nullable=False, index=True)
    
    # Message content
    role = Column(String, nullable=False)  # 'user', 'assistant', or 'tool'
    content = Column(Text, nullable=False)
    
    # Sequence number within the chat (for ordering)
    sequence = Column(Integer, nullable=False)
    
    # Tool call data (for assistant messages that call tools)
    tool_calls = Column(JSONB, nullable=True)
    
    # Tool result metadata (for tool role messages)
    tool_call_id = Column(String, nullable=True, index=True)
    name = Column(String, nullable=True)  # Tool/function name
    
    # Performance metrics (for assistant messages)
    latency_ms = Column(Integer, nullable=True)  # Response time in milliseconds
    
    # Foreign key to resource (for tool result messages)
    resource_id = Column(String, nullable=True, index=True)
    
    # Timestamp
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<ChatMessage(id={self.id}, chat_id='{self.chat_id}', role='{self.role}', seq={self.sequence})>"


class Resource(Base):
    """
    Stores function call results as resources that users can browse
    
    Resources contain the full data from tool/function executions.
    ChatMessages can optionally reference a resource via resource_id.
    """
    __tablename__ = "resources"
    
    # Primary key
    id = Column(String, primary_key=True, index=True)
    
    # Links to chat and user (for querying all resources in a chat/user)
    chat_id = Column(String, nullable=False, index=True)
    user_id = Column(String, nullable=False, index=True)
    
    # Tool call information
    tool_name = Column(String, nullable=False)
    
    # Resource metadata
    resource_type = Column(String, nullable=False)  # 'portfolio', 'insider_trades', 'reddit_trends', etc.
    title = Column(String, nullable=False)
    
    # Resource data (stored as JSONB for efficient querying)
    data = Column(JSONB, nullable=False)
    resource_metadata = Column(JSONB, nullable=True)  # Additional metadata like parameters
    
    # Timestamp
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)
    
    def __repr__(self):
        return f"<Resource(id='{self.id}', type='{self.resource_type}', tool='{self.tool_name}')>"


class BrokerageAccount(Base):
    """
    Stores individual brokerage account connections
    
    Each connected brokerage account is tracked separately with full metadata.
    This allows users to connect multiple brokerages and manage them individually.
    """
    __tablename__ = "brokerage_accounts"
    
    # Primary key (UUID)
    id = Column(String, primary_key=True, index=True)
    
    # User ID (Supabase UUID)
    user_id = Column(String, nullable=False, index=True)
    
    # SnapTrade account ID
    account_id = Column(String, nullable=False, index=True)
    
    # Brokerage information
    broker_id = Column(String, nullable=False)  # e.g., "ROBINHOOD", "ALPACA"
    broker_name = Column(String, nullable=False)  # e.g., "Robinhood", "Alpaca"
    
    # Account details
    account_name = Column(String, nullable=True)  # User-friendly name
    account_number = Column(String, nullable=True)  # Masked account number
    account_type = Column(String, nullable=True)  # e.g., "TFSA", "IRA Roth", "margin"
    balance = Column(Integer, nullable=True)  # Balance in cents (for precision)
    
    # Additional metadata
    account_metadata = Column(JSONB, nullable=True)
    
    # Status tracking
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    connected_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_synced_at = Column(DateTime(timezone=True), nullable=True)
    disconnected_at = Column(DateTime(timezone=True), nullable=True)
    
    def __repr__(self):
        return f"<BrokerageAccount(id='{self.id}', user='{self.user_id}', broker='{self.broker_name}', active={self.is_active})>"


class Transaction(Base):
    """
    Stores all user transactions - flexible JSON schema
    MVP: Stocks only - options and crypto excluded
    
    Key fields are indexed for fast queries, all other data in JSONB
    """
    __tablename__ = "transactions"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User and account (indexed)
    user_id = Column(String, nullable=False, index=True)
    account_id = Column(String, nullable=False, index=True)
    
    # Key indexed fields for filtering
    symbol = Column(String(20), nullable=False, index=True)
    transaction_type = Column(String(20), nullable=False)  # BUY, SELL, DIVIDEND, FEE, TRANSFER, SPLIT
    transaction_date = Column(DateTime(timezone=True), nullable=False, index=True)
    external_id = Column(String, nullable=True)  # SnapTrade ID for deduplication
    
    # All transaction data in JSONB (quantity, price, fee, P&L, etc.)
    data = Column(JSONB, nullable=False)
    
    # Tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<Transaction(id='{self.id}', symbol='{self.symbol}', type='{self.transaction_type}')>"


class TransactionSyncJob(Base):
    """
    Tracks sync operations - flexible JSON schema
    """
    __tablename__ = "transaction_sync_jobs"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User (indexed)
    user_id = Column(String, nullable=False, index=True)
    status = Column(String(20), nullable=False)  # pending, running, completed, failed
    
    # All job data in JSONB (account_id, dates, results, error_message, etc.)
    data = Column(JSONB, nullable=False)
    
    # Timing
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    def __repr__(self):
        return f"<TransactionSyncJob(id='{self.id}', user='{self.user_id}', status='{self.status}')>"


class PortfolioSnapshot(Base):
    """
    Daily portfolio snapshots - flexible JSON schema
    """
    __tablename__ = "portfolio_snapshots"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User and date (indexed)
    user_id = Column(String, nullable=False, index=True)
    snapshot_date = Column(Date, nullable=False, index=True)
    
    # All snapshot data in JSONB (value, cost_basis, P&L, holdings, etc.)
    data = Column(JSONB, nullable=False)
    
    # Tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<PortfolioSnapshot(id='{self.id}', user='{self.user_id}', date='{self.snapshot_date}')>"


class TradeAnalytics(Base):
    """
    Cached analysis results for closed positions - flexible JSON schema
    """
    __tablename__ = "trade_analytics"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User, symbol, and exit date (indexed)
    user_id = Column(String, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    exit_date = Column(DateTime(timezone=True), nullable=False, index=True)
    
    # All analytics data in JSONB (prices, P&L, grades, AI commentary, etc.)
    data = Column(JSONB, nullable=False)
    
    # Tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<TradeAnalytics(id='{self.id}', symbol='{self.symbol}')>"


class TradingStrategyDB(Base):
    """
    Stores user-created trading strategies - flexible JSON schema
    Strategies are defined in natural language, parsed by LLM, and stored as structured JSON
    """
    __tablename__ = "trading_strategies"
    
    # Primary key
    id = Column(String(36), primary_key=True, index=True)
    
    # User (indexed)
    user_id = Column(String, nullable=False, index=True)
    
    # Strategy metadata
    name = Column(String(255), nullable=False)
    description = Column(Text)
    natural_language_input = Column(Text, nullable=False)  # Original user input
    
    # Full strategy definition in JSONB (TradingStrategy model)
    strategy_definition = Column(JSONB, nullable=False)
    
    # Status
    is_active = Column(Boolean, default=True)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), nullable=False)
    updated_at = Column(DateTime(timezone=True), nullable=False)
    
    def __repr__(self):
        return f"<TradingStrategy(id='{self.id}', name='{self.name}', user='{self.user_id}')>"


class StrategyBacktestDB(Base):
    """
    Stores backtest results for strategies - flexible JSON schema
    """
    __tablename__ = "strategy_backtests"
    
    # Primary key
    backtest_id = Column(String(36), primary_key=True, index=True)
    
    # Strategy reference (indexed)
    strategy_id = Column(String(36), nullable=False, index=True)
    
    # Backtest period
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    
    # Full backtest results in JSONB (StrategyBacktest model)
    backtest_results = Column(JSONB, nullable=False)
    
    # Timestamp
    created_at = Column(DateTime(timezone=True), nullable=False)
    
    def __repr__(self):
        return f"<StrategyBacktest(id='{self.backtest_id}', strategy='{self.strategy_id}')>"


class StrategySignalDB(Base):
    """
    Stores live trade signals generated by strategies
    """
    __tablename__ = "strategy_signals"
    
    # Primary key
    signal_id = Column(String(36), primary_key=True, index=True)
    
    # Strategy reference (indexed)
    strategy_id = Column(String(36), nullable=False, index=True)
    
    # Signal details
    ticker = Column(String(10), nullable=False, index=True)
    signal_type = Column(String(10), nullable=False)  # entry/exit
    generated_at = Column(DateTime(timezone=True), nullable=False, index=True)
    price_at_signal = Column(Numeric(precision=10, scale=2))
    confidence_score = Column(Float)
    reasoning = Column(Text)
    data_snapshot = Column(JSONB)
    
    # User interaction tracking
    user_acted = Column(Boolean, default=False)
    outcome = Column(JSONB)  # If user took trade, track result
    
    def __repr__(self):
        return f"<StrategySignal(id='{self.signal_id}', ticker='{self.ticker}', type='{self.signal_type}')>"


class StrategyPerformanceDB(Base):
    """
    Tracks live performance of strategies
    """
    __tablename__ = "strategy_performance"
    
    # Primary key
    id = Column(String(36), primary_key=True, index=True)
    
    # Strategy reference (indexed, unique)
    strategy_id = Column(String(36), nullable=False, unique=True, index=True)
    user_id = Column(String, nullable=False, index=True)
    
    # Signal tracking
    signals_generated = Column(Integer, default=0)
    signals_acted_on = Column(Integer, default=0)
    
    # Actual performance (user took trades)
    actual_trades = Column(Integer, default=0)
    actual_wins = Column(Integer, default=0)
    actual_losses = Column(Integer, default=0)
    actual_return_pct = Column(Float, default=0.0)
    
    # Hypothetical performance (if user took all signals)
    hypothetical_trades = Column(Integer, default=0)
    hypothetical_return_pct = Column(Float, default=0.0)
    
    # Last activity
    last_signal_date = Column(DateTime(timezone=True))
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), nullable=False)
    updated_at = Column(DateTime(timezone=True), nullable=False)
    
    def __repr__(self):
        return f"<StrategyPerformance(strategy='{self.strategy_id}', signals={self.signals_generated})>"


# ============================================================================
# V2 STRATEGY MODELS (Modern LLM-Native Framework)
# ============================================================================

class TradingStrategyV2DB(Base):
    """V2 Strategy - Clean & Composable"""
    __tablename__ = "strategies_v2"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, nullable=False, index=True)
    chat_id = Column(String, nullable=False, index=True)
    name = Column(String, nullable=False)
    description = Column(Text)
    
    # Candidates: where to find stocks
    candidate_source = Column(JSONB, nullable=False)
    
    # Rules: all stored as JSONB
    screening_rules = Column(JSONB, nullable=False)  # BUY/SKIP decisions
    management_rules = Column(JSONB, nullable=True)  # BUY/HOLD/SELL decisions
    
    # Risk parameters
    risk_parameters = Column(JSONB, nullable=False)
    
    is_active = Column(Boolean, default=True, index=True)
    created_at = Column(DateTime(timezone=True), nullable=False)
    updated_at = Column(DateTime(timezone=True), nullable=False)
    
    def __repr__(self):
        return f"<TradingStrategyV2(id='{self.id}', name='{self.name}')>"


class StrategyPositionDB(Base):
    """Track positions held by strategies"""
    __tablename__ = "strategy_positions"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    strategy_id = Column(String, nullable=False, index=True)
    user_id = Column(String, nullable=False, index=True)
    chat_id = Column(String, nullable=False, index=True)
    ticker = Column(String, nullable=False, index=True)
    
    # Entry
    shares = Column(Float, nullable=False)
    entry_price = Column(Float, nullable=False)
    entry_date = Column(DateTime(timezone=True), nullable=False)
    entry_decision_id = Column(String, nullable=False)
    
    # Current state
    current_price = Column(Float, default=0.0)
    current_value = Column(Float, default=0.0)
    pnl = Column(Float, default=0.0)
    pnl_pct = Column(Float, default=0.0)
    days_held = Column(Integer, default=0)
    
    # Exit
    exit_date = Column(DateTime(timezone=True), nullable=True)
    exit_price = Column(Float, nullable=True)
    exit_decision_id = Column(String, nullable=True)
    is_open = Column(Boolean, default=True, index=True)
    
    created_at = Column(DateTime(timezone=True), nullable=False)
    updated_at = Column(DateTime(timezone=True), nullable=False)
    
    def __repr__(self):
        return f"<StrategyPosition(ticker='{self.ticker}', pnl={self.pnl_pct}%)>"


class StrategyBudgetDB(Base):
    """Track strategy budgets"""
    __tablename__ = "strategy_budgets"
    
    strategy_id = Column(String, primary_key=True)
    user_id = Column(String, nullable=False, index=True)
    chat_id = Column(String, nullable=False, index=True)
    
    total_budget = Column(Float, default=1000.0)
    cash_available = Column(Float, nullable=False)
    position_value = Column(Float, default=0.0)
    
    updated_at = Column(DateTime(timezone=True), nullable=False)
    
    def __repr__(self):
        return f"<StrategyBudget(cash=${self.cash_available}, positions=${self.position_value})>"


class StrategyDecisionDB(Base):
    """Strategy decision records"""
    __tablename__ = "strategy_decisions"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    strategy_id = Column(String, nullable=False, index=True)
    chat_id = Column(String, nullable=False, index=True)
    ticker = Column(String, nullable=False, index=True)
    timestamp = Column(DateTime(timezone=True), nullable=False, index=True)
    
    action = Column(String, nullable=False)  # BUY/SELL/HOLD/SKIP
    confidence = Column(Float)
    reasoning = Column(Text)
    
    rule_results = Column(JSONB)
    data_snapshot = Column(JSONB)
    position_data = Column(JSONB, nullable=True)
    
    current_price = Column(Float)
    
    def __repr__(self):
        return f"<StrategyDecision(ticker='{self.ticker}', action='{self.action}')>"


class ChatFile(Base):
    """
    Stores files created during chat sessions (Manus-inspired)
    
    Files are scoped to chats and stored in database for:
    - Multi-device access
    - Persistence
    - Proper chat context
    - User visibility in UI
    
    Examples: generated Python code, todo.md, analysis results, CSV exports
    """
    __tablename__ = "chat_files"
    
    # Primary key
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    
    # Chat scope (indexed)
    chat_id = Column(String, nullable=False, index=True)
    user_id = Column(String, nullable=False, index=True)
    
    # File metadata
    filename = Column(String, nullable=False)  # e.g., "growth_analysis.py", "todo.md"
    file_type = Column(String, nullable=False)  # "python", "markdown", "text", "csv"
    content = Column(Text, nullable=False)  # File content (text)
    size_bytes = Column(Integer, nullable=False)  # Content size
    
    # Optional metadata
    description = Column(String, nullable=True)  # Brief description
    file_metadata = Column(JSONB, nullable=True)  # Extra data (function_name, data_sources, etc.)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<ChatFile(id='{self.id}', chat='{self.chat_id}', filename='{self.filename}')>"

