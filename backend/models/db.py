"""
SQLAlchemy database models
"""
from sqlalchemy import Column, String, DateTime, Text, Boolean, Integer, Numeric, Date, ARRAY, Float
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.sql import func
from database import Base
import uuid


class SnapTradeUser(Base):
    """
    Stores SnapTrade user connections per user
    
    SnapTrade handles OAuth authentication, but we need to store the userSecret
    that SnapTrade generates for each user so we can make API calls on their behalf.
    
    SECURITY:
    - userSecret is sensitive and should be treated like a password
    - OAuth flow handled by SnapTrade
    - We store user_id (Supabase UUID), userSecret, and account references
    """
    __tablename__ = "snaptrade_users"
    
    # Primary key (Supabase user ID from OAuth)
    user_id = Column(String, primary_key=True, index=True)
    
    # SnapTrade user ID (returned after registering user with SnapTrade)
    snaptrade_user_id = Column(String, unique=True, nullable=False, index=True)
    
    # SnapTrade user secret (generated by SnapTrade, needed for all API calls)
    snaptrade_user_secret = Column(Text, nullable=False)
    
    # SnapTrade account IDs (JSON array of connected account IDs)
    # Stored as comma-separated string for simplicity
    connected_account_ids = Column(Text, nullable=True)
    
    # Connection metadata
    is_connected = Column(Boolean, default=False, nullable=False)
    brokerage_name = Column(String, nullable=True)  # e.g., "Robinhood", "TD Ameritrade"
    
    # Session tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_activity = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<SnapTradeUser(user_id='{self.user_id}', snaptrade_user_id='{self.snaptrade_user_id}', is_connected={self.is_connected})>"


class Chat(Base):
    """
    Stores chat session metadata
    
    Each chat represents a conversation thread between the user and the AI.
    Users can have multiple chats, and can switch between them.
    """
    __tablename__ = "chats"
    
    # Primary key
    chat_id = Column(String, primary_key=True, index=True)
    
    # User ID (links to the same user_id used in SnapTradeUser)
    user_id = Column(String, nullable=False, index=True)
    
    # Chat metadata
    title = Column(String, nullable=True)  # Auto-generated or user-set title
    icon = Column(String(10), nullable=True)  # Emoji icon for the chat (LLM-generated)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<Chat(chat_id='{self.chat_id}', user_id='{self.user_id}', title='{self.title}', icon='{self.icon}')>"


class ChatMessage(Base):
    """
    Stores individual chat messages within a chat session (OpenAI format)
    
    Each message belongs to a chat and has a role (user, assistant, or tool).
    Messages are ordered by their sequence number within the chat.
    
    Message types (matching OpenAI API format):
    - user: User input messages (content field only)
    - assistant: AI responses (content field, optionally tool_calls JSONB)
    - tool: Tool/function results (content field, tool_call_id, name, and resource_id FK)
    """
    __tablename__ = "chat_messages"
    
    # Primary key (auto-increment)
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign key to chat
    chat_id = Column(String, nullable=False, index=True)
    
    # Message content
    role = Column(String, nullable=False)  # 'user', 'assistant', or 'tool'
    content = Column(Text, nullable=False)
    
    # Sequence number within the chat (for ordering)
    sequence = Column(Integer, nullable=False)
    
    # Tool call data (for assistant messages that call tools)
    tool_calls = Column(JSONB, nullable=True)
    
    # Tool execution results (for assistant messages with tool_calls)
    # Stores code_output, result_summary, errors etc. keyed by tool_call_id
    tool_results = Column(JSONB, nullable=True)
    
    # Tool result metadata (for tool role messages)
    tool_call_id = Column(String, nullable=True, index=True)
    name = Column(String, nullable=True)  # Tool/function name
    
    # Performance metrics (for assistant messages)
    latency_ms = Column(Integer, nullable=True)  # Response time in milliseconds
    
    # Foreign key to resource (for tool result messages)
    resource_id = Column(String, nullable=True, index=True)
    
    # Timestamp
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<ChatMessage(id={self.id}, chat_id='{self.chat_id}', role='{self.role}', seq={self.sequence})>"


class Resource(Base):
    """
    Stores function call results as resources that users can browse
    
    Resources contain the full data from tool/function executions.
    ChatMessages can optionally reference a resource via resource_id.
    """
    __tablename__ = "resources"
    
    # Primary key
    id = Column(String, primary_key=True, index=True)
    
    # Links to chat and user (for querying all resources in a chat/user)
    chat_id = Column(String, nullable=False, index=True)
    user_id = Column(String, nullable=False, index=True)
    
    # Tool call information
    tool_name = Column(String, nullable=False)
    
    # Resource metadata
    resource_type = Column(String, nullable=False)  # 'portfolio', 'insider_trades', 'reddit_trends', etc.
    title = Column(String, nullable=False)
    
    # Resource data (stored as JSONB for efficient querying)
    data = Column(JSONB, nullable=False)
    resource_metadata = Column(JSONB, nullable=True)  # Additional metadata like parameters
    
    # Timestamp
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)
    
    def __repr__(self):
        return f"<Resource(id='{self.id}', type='{self.resource_type}', tool='{self.tool_name}')>"


class BrokerageAccount(Base):
    """
    Stores individual brokerage account connections
    
    Each connected brokerage account is tracked separately with full metadata.
    This allows users to connect multiple brokerages and manage them individually.
    """
    __tablename__ = "brokerage_accounts"
    
    # Primary key (UUID)
    id = Column(String, primary_key=True, index=True)
    
    # User ID (Supabase UUID)
    user_id = Column(String, nullable=False, index=True)
    
    # SnapTrade account ID
    account_id = Column(String, nullable=False, index=True)
    
    # Brokerage information
    broker_id = Column(String, nullable=False)  # e.g., "ROBINHOOD", "ALPACA"
    broker_name = Column(String, nullable=False)  # e.g., "Robinhood", "Alpaca"
    
    # Account details
    account_name = Column(String, nullable=True)  # User-friendly name
    account_number = Column(String, nullable=True)  # Masked account number
    account_type = Column(String, nullable=True)  # e.g., "TFSA", "IRA Roth", "margin"
    balance = Column(Integer, nullable=True)  # Balance in cents (for precision)
    
    # Additional metadata
    account_metadata = Column(JSONB, nullable=True)
    
    # Status tracking
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    connected_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_synced_at = Column(DateTime(timezone=True), nullable=True)
    disconnected_at = Column(DateTime(timezone=True), nullable=True)
    
    def __repr__(self):
        return f"<BrokerageAccount(id='{self.id}', user='{self.user_id}', broker='{self.broker_name}', active={self.is_active})>"


class Transaction(Base):
    """
    Stores all user transactions - flexible JSON schema
    MVP: Stocks only - options and crypto excluded
    
    Key fields are indexed for fast queries, all other data in JSONB
    """
    __tablename__ = "transactions"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User and account (indexed)
    user_id = Column(String, nullable=False, index=True)
    account_id = Column(String, nullable=False, index=True)
    
    # Key indexed fields for filtering
    symbol = Column(String(20), nullable=False, index=True)
    transaction_type = Column(String(20), nullable=False)  # BUY, SELL, DIVIDEND, FEE, TRANSFER, SPLIT
    transaction_date = Column(DateTime(timezone=True), nullable=False, index=True)
    external_id = Column(String, nullable=True)  # SnapTrade ID for deduplication
    
    # All transaction data in JSONB (quantity, price, fee, P&L, etc.)
    data = Column(JSONB, nullable=False)
    
    # Tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<Transaction(id='{self.id}', symbol='{self.symbol}', type='{self.transaction_type}')>"


class TransactionSyncJob(Base):
    """
    Tracks sync operations - flexible JSON schema
    """
    __tablename__ = "transaction_sync_jobs"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User (indexed)
    user_id = Column(String, nullable=False, index=True)
    status = Column(String(20), nullable=False)  # pending, running, completed, failed
    
    # All job data in JSONB (account_id, dates, results, error_message, etc.)
    data = Column(JSONB, nullable=False)
    
    # Timing
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    def __repr__(self):
        return f"<TransactionSyncJob(id='{self.id}', user='{self.user_id}', status='{self.status}')>"


class PortfolioSnapshot(Base):
    """
    Daily portfolio snapshots - flexible JSON schema
    """
    __tablename__ = "portfolio_snapshots"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User and date (indexed)
    user_id = Column(String, nullable=False, index=True)
    snapshot_date = Column(Date, nullable=False, index=True)
    
    # All snapshot data in JSONB (value, cost_basis, P&L, holdings, etc.)
    data = Column(JSONB, nullable=False)
    
    # Tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<PortfolioSnapshot(id='{self.id}', user='{self.user_id}', date='{self.snapshot_date}')>"


class TradeAnalytics(Base):
    """
    Cached analysis results for closed positions - flexible JSON schema
    """
    __tablename__ = "trade_analytics"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    
    # User, symbol, and exit date (indexed)
    user_id = Column(String, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    exit_date = Column(DateTime(timezone=True), nullable=False, index=True)
    
    # All analytics data in JSONB (prices, P&L, grades, AI commentary, etc.)
    data = Column(JSONB, nullable=False)
    
    # Tracking
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<TradeAnalytics(id='{self.id}', symbol='{self.symbol}')>"


class UserSettings(Base):
    """
    Stores user settings with encrypted API credentials
    
    SECURITY ARCHITECTURE:
    - `encrypted_api_keys`: Contains ALL API credentials as a single encrypted blob
      The entire JSON object is encrypted with Fernet (AES-128-CBC + HMAC)
      before storage - not individual fields. This ensures:
      1. No partial leaks possible
      2. Can't query/filter on credential values
      3. Encryption is all-or-nothing
    
    - `settings`: Non-sensitive preferences (theme, etc.) stored as plain JSONB
    
    Encrypted blob structure (decrypted):
    {
        "kalshi": {
            "api_key_id": "abc123",
            "private_key": "-----BEGIN PRIVATE KEY-----...",
            "created_at": "2024-01-01T00:00:00Z"
        }
    }
    
    SECURITY NOTES:
    - Decrypted credentials should NEVER be logged
    - Decrypted credentials should NEVER be returned to frontend
    - Frontend only sees: service name, masked key ID, has_private_key bool
    - All decryption happens server-side, on-demand, for API calls only
    - Fernet key must be kept secret (ENCRYPTION_KEY env var)
    """
    __tablename__ = "user_settings"
    
    # Primary key is user_id (one row per user)
    user_id = Column(String, primary_key=True, index=True)
    
    # Encrypted API credentials blob (Fernet encrypted JSON string)
    # This is the ONLY place secrets are stored
    encrypted_api_keys = Column(Text, nullable=True)
    
    # Non-sensitive settings (theme, preferences, etc.)
    settings = Column(JSONB, nullable=False, default=dict)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        # Never log anything about credentials
        return f"<UserSettings(user_id='{self.user_id}')>"


class ChatFile(Base):
    """
    Stores files created during chat sessions (Manus-inspired)
    
    Files are scoped to chats and stored in database for:
    - Multi-device access
    - Persistence
    - Proper chat context
    - User visibility in UI
    
    Examples: generated Python code, todo.md, analysis results, CSV exports
    """
    __tablename__ = "chat_files"
    
    # Primary key
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    
    # Chat scope (indexed)
    chat_id = Column(String, nullable=False, index=True)
    user_id = Column(String, nullable=False, index=True)
    
    # File metadata
    filename = Column(String, nullable=False)  # e.g., "growth_analysis.py", "todo.md"
    file_type = Column(String, nullable=False)  # "python", "markdown", "text", "csv", "image"
    content = Column(Text, nullable=True)  # File content (text) - nullable for images
    size_bytes = Column(Integer, nullable=False)  # Content size
    
    # Image storage (for image files only)
    image_url = Column(String, nullable=True)  # Public URL from Supabase Storage (if image)
    
    # Optional metadata
    description = Column(String, nullable=True)  # Brief description
    file_metadata = Column(JSONB, nullable=True)  # Extra data (function_name, data_sources, etc.)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<ChatFile(id='{self.id}', chat='{self.chat_id}', filename='{self.filename}')>"


class Strategy(Base):
    """
    Automated trading strategies owned by users
    
    Strategies are:
    - Created via chat (LLM generates code files)
    - Stored as references to ChatFile IDs
    - Executed on schedule or manually
    - Require approval before live trading
    
    Uses JSONB for flexibility - only essential query fields are columns.
    
    config JSONB structure:
    {
        "description": "Plain language description",
        "source_chat_id": "chat_abc123",
        "file_ids": ["file_1", "file_2"],
        "entrypoint": "strategy.py",
        "schedule": "0 * * * *",  # Cron expression
        "schedule_description": "Every hour",
        "risk_limits": {
            "max_order_usd": 100,
            "max_daily_usd": 500,
            "allowed_services": ["kalshi", "alpaca"]
        },
        "approved_at": "2025-01-08T..."
    }
    
    stats JSONB structure:
    {
        "total_runs": 42,
        "successful_runs": 40,
        "failed_runs": 2,
        "last_run_at": "2025-01-08T...",
        "last_run_status": "success",
        "last_run_summary": "Bought 2 contracts for $35",
        "total_spent_usd": 1250.00,
        "total_profit_usd": 320.00,
        ... any other stats we want to track
    }
    """
    __tablename__ = "strategies"
    
    # Primary key
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    
    # Owner (indexed for user queries)
    user_id = Column(String, nullable=False, index=True)
    
    # Core identity (indexed)
    name = Column(String, nullable=False)
    enabled = Column(Boolean, nullable=False, default=False, index=True)
    approved = Column(Boolean, nullable=False, default=False)
    
    # Flexible JSONB columns
    config = Column(JSONB, nullable=False, default=dict)  # Configuration, file refs, risk limits
    stats = Column(JSONB, nullable=False, default=dict)  # Execution stats, P&L tracking
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<Strategy(id='{self.id}', name='{self.name}', enabled={self.enabled})>"


class StrategyExecution(Base):
    """
    Audit log of strategy executions
    
    Every time a strategy runs (scheduled, manual, or dry run), we log it.
    Uses JSONB for all execution details.
    
    data JSONB structure:
    {
        "trigger": "scheduled" | "manual" | "dry_run",
        "completed_at": "2025-01-08T...",
        "result": { ... return value from strategy ... },
        "error": "Error message if failed",
        "logs": ["log line 1", "log line 2"],
        "summary": "Checked 5 markets, bought 2 for $45",
        "actions": [
            {"type": "kalshi_order", "ticker": "FED-25JAN", "side": "yes", "amount_usd": 25},
            {"type": "kalshi_order", "ticker": "FED-25MAR", "side": "yes", "amount_usd": 20}
        ],
        "duration_ms": 1234,
        "markets_checked": 5,
        ... any other execution metadata
    }
    """
    __tablename__ = "strategy_executions"
    
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Foreign keys (indexed)
    strategy_id = Column(String, nullable=False, index=True)
    user_id = Column(String, nullable=False, index=True)
    
    # Indexed for queries
    status = Column(String, nullable=False)  # 'running', 'success', 'failed'
    started_at = Column(DateTime(timezone=True), nullable=False, index=True)
    
    # Everything else in JSONB
    data = Column(JSONB, nullable=False, default=dict)
    
    def __repr__(self):
        return f"<StrategyExecution(id='{self.id}', strategy='{self.strategy_id}', status='{self.status}')>"

