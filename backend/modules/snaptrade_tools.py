"""
SnapTrade tools for portfolio management

SECURITY NOTES:
- No credentials are stored or passed through the app
- OAuth authentication is handled by SnapTrade
- Users connect their brokerages securely through SnapTrade's Connection Portal
"""
from snaptrade_client import SnapTrade
from typing import Dict, Any, Optional, List
from datetime import datetime
from pydantic import BaseModel
from config import Config
from database import SessionLocal
from crud import snaptrade_user as snaptrade_crud
from models.db import SnapTradeUser as DBSnapTradeUser
from models.snaptrade import (
    Position, Account, AggregatedHolding, Portfolio,
    SnapTradePositionResponse, SnapTradeAccountResponse
)


class SnapTradeSession(BaseModel):
    """
    Session data for a SnapTrade user
    SECURITY: Only stores connection status and user ID, no credentials
    """
    snaptrade_user_id: str
    snaptrade_user_secret: str  # Generated by SnapTrade, needed for API calls
    is_connected: bool
    last_activity: str  # ISO format timestamp
    account_ids: Optional[List[str]] = None
    
    class Config:
        validate_assignment = True


class SnapTradeTools:
    """
    Tools for interacting with SnapTrade API
    
    SECURITY ARCHITECTURE:
    - OAuth flow: Frontend → SnapTrade Portal → Callback → Backend
    - No credentials ever pass through our app
    - SnapTrade manages all authentication and token storage
    - We only store SnapTrade user IDs and connection status
    """
    
    def __init__(self):
        # Initialize SnapTrade client
        self.client = SnapTrade(
            consumer_key=Config.SNAPTRADE_CONSUMER_KEY,
            client_id=Config.SNAPTRADE_CLIENT_ID
        )
        # Cache sessions in memory for performance (but also persist to DB)
        self._sessions: Dict[str, SnapTradeSession] = {}
    
    def _get_session(self, session_id: str) -> Optional[SnapTradeSession]:
        """Get session from cache or database"""
        # Check cache first
        if session_id in self._sessions:
            return self._sessions[session_id]
        
        # Load from database
        db = SessionLocal()
        try:
            db_user = snaptrade_crud.get_user_by_session(db, session_id)
            if db_user and db_user.snaptrade_user_secret:
                # Restore to cache
                session = SnapTradeSession(
                    snaptrade_user_id=db_user.snaptrade_user_id,
                    snaptrade_user_secret=db_user.snaptrade_user_secret,
                    is_connected=db_user.is_connected,
                    last_activity=db_user.last_activity.isoformat(),
                    account_ids=db_user.connected_account_ids.split(',') if db_user.connected_account_ids else []
                )
                self._sessions[session_id] = session
                print(f"✅ Loaded session from database: {session_id}", flush=True)
                return session
        finally:
            db.close()
        
        return None
    
    def _save_session(self, session_id: str, session: SnapTradeSession):
        """Save session to both cache and database"""
        # Update cache
        self._sessions[session_id] = session
        
        # Save to database
        db = SessionLocal()
        try:
            db_user = snaptrade_crud.get_user_by_session(db, session_id)
            if db_user:
                # Update existing
                db_user.snaptrade_user_secret = session.snaptrade_user_secret
                db_user.is_connected = session.is_connected
                db_user.connected_account_ids = ','.join(session.account_ids) if session.account_ids else None
                db_user.last_activity = datetime.utcnow()
                db.commit()
            else:
                # Create new
                snaptrade_crud.create_user(
                    db=db,
                    session_id=session_id,
                    snaptrade_user_id=session.snaptrade_user_id,
                    snaptrade_user_secret=session.snaptrade_user_secret
                )
                if session.is_connected and session.account_ids:
                    snaptrade_crud.update_connection_status(
                        db=db,
                        session_id=session_id,
                        is_connected=True,
                        account_ids=','.join(session.account_ids)
                    )
        finally:
            db.close()
    
    def _get_accounts(self, session_id: str, user_secret: str) -> List[SnapTradeAccountResponse]:
        """Get user's accounts from SnapTrade and parse with Pydantic"""
        response = self.client.account_information.list_user_accounts(
            user_id=session_id,
            user_secret=user_secret
        )
        accounts_data = response.body if hasattr(response, 'body') else response
        
        # Parse using Pydantic models
        parsed_accounts = []
        for account_data in accounts_data:
            try:
                account = SnapTradeAccountResponse(**account_data) if isinstance(account_data, dict) else account_data
                parsed_accounts.append(account)
            except Exception as e:
                print(f"⚠️ Error parsing account: {e}", flush=True)
                continue
        
        return parsed_accounts
    
    def _get_positions_for_account(self, session_id: str, user_secret: str, account_id: str) -> List[Position]:
        """Get positions for a specific account and parse with Pydantic"""
        response = self.client.account_information.get_user_account_positions(
            user_id=session_id,
            user_secret=user_secret,
            account_id=account_id
        )
        positions_data = response.body if hasattr(response, 'body') else response
        
        # Parse using Pydantic
        parsed_positions = []
        if positions_data:
            for position_data in positions_data:
                try:
                    pos_response = SnapTradePositionResponse(**position_data) if isinstance(position_data, dict) else position_data
                    position = pos_response.to_position()
                    if position.quantity > 0:
                        parsed_positions.append(position)
                except Exception as e:
                    print(f"⚠️ Error parsing position: {e}", flush=True)
                    continue
        
        return parsed_positions
    
    def _handle_user_already_exists(self, session_id: str) -> Dict[str, Any]:
        """Handle the case where a SnapTrade user already exists"""
        print(f"⚠️ User already exists in SnapTrade, trying to delete and recreate...", flush=True)
        
        # Try to delete the existing user first
        try:
            self.client.authentication.delete_snap_trade_user(user_id=session_id)
            print(f"✅ Deleted existing SnapTrade user: {session_id}", flush=True)
        except Exception as delete_error:
            print(f"⚠️ Could not delete user (might not have permission): {str(delete_error)}", flush=True)
            return {
                "success": False,
                "message": "Session conflict detected. Please refresh the page to create a new session.",
                "requires_new_session": True
            }
        
        # Try registering again after deletion
        try:
            response = self.client.authentication.register_snap_trade_user(
                body={"userId": session_id}
            )
            
            response_data = response.body if hasattr(response, 'body') else response
            snaptrade_user_id = response_data.get('userId') or session_id
            snaptrade_user_secret = response_data.get('userSecret')
            
            if not snaptrade_user_secret:
                raise Exception("No userSecret returned after recreation")
            
            # Store session with new userSecret
            session = SnapTradeSession(
                snaptrade_user_id=snaptrade_user_id,
                snaptrade_user_secret=snaptrade_user_secret,
                is_connected=False,
                last_activity=datetime.now().isoformat()
            )
            self._save_session(session_id, session)
            
            print(f"✅ Recreated SnapTrade user: {snaptrade_user_id}", flush=True)
            
            return {
                "success": True,
                "snaptrade_user_id": snaptrade_user_id,
                "snaptrade_user_secret": snaptrade_user_secret
            }
        except Exception as recreate_error:
            print(f"❌ Error recreating user: {str(recreate_error)}", flush=True)
            return {
                "success": False,
                "message": "Session conflict detected. Please refresh the page to create a new session.",
                "requires_new_session": True
            }
    
    def register_user(self, session_id: str) -> Dict[str, Any]:
        """
        Register a new user with SnapTrade
        
        This creates a SnapTrade user ID and receives a userSecret from SnapTrade.
        The userSecret is generated by SnapTrade and must be stored for all future API calls.
        
        Args:
            session_id: Our internal session ID (used as SnapTrade userId)
            
        Returns:
            Dictionary with snaptrade_user_id and snaptrade_user_secret
        """
        try:
            # Register user with SnapTrade
            # Using session_id as the user_id for consistency
            response = self.client.authentication.register_snap_trade_user(
                body={
                    "userId": session_id
                }
            )
            
            # SnapTrade SDK returns an ApiResponse object, need to access body
            response_data = response.body if hasattr(response, 'body') else response
            
            snaptrade_user_id = response_data.get('userId') or session_id
            snaptrade_user_secret = response_data.get('userSecret')
            
            if not snaptrade_user_secret:
                raise Exception("No userSecret returned from SnapTrade")
            
            # Store session
            session = SnapTradeSession(
                snaptrade_user_id=snaptrade_user_id,
                snaptrade_user_secret=snaptrade_user_secret,
                is_connected=False,
                last_activity=datetime.now().isoformat()
            )
            self._save_session(session_id, session)
            
            print(f"✅ Registered SnapTrade user and saved to DB: {snaptrade_user_id}", flush=True)
            
            return {
                "success": True,
                "snaptrade_user_id": snaptrade_user_id,
                "snaptrade_user_secret": snaptrade_user_secret
            }
        except Exception as e:
            error_str = str(e)
            print(f"❌ Error registering user: {error_str}", flush=True)
            
            # Check if user already exists (error code 1010)
            if "already exist" in error_str or "1010" in error_str:
                return self._handle_user_already_exists(session_id)
            
            return {
                "success": False,
                "message": f"Failed to register user: {error_str}"
            }
    
    def get_login_redirect_uri(self, session_id: str, redirect_uri: str) -> Dict[str, Any]:
        """
        Get the SnapTrade Connection Portal URL for OAuth login
        
        Args:
            session_id: User session ID (also used as SnapTrade user_id)
            redirect_uri: Where to redirect after successful connection
            
        Returns:
            Dictionary with redirect URL
        """
        try:
            # Get or load session
            session = self._get_session(session_id)
            
            # If no session exists, register user
            if not session:
                register_result = self.register_user(session_id)
                if not register_result["success"]:
                    return register_result
                session = self._get_session(session_id)
            if not session or not session.snaptrade_user_secret:
                return {
                    "success": False,
                    "message": "User not registered properly. Please try again."
                }
            
            # Get login redirect URI from SnapTrade
            response = self.client.authentication.login_snap_trade_user(
                user_id=session_id,
                user_secret=session.snaptrade_user_secret,
                body={
                    "broker": "ROBINHOOD",  # Specify Robinhood
                    "immediateRedirect": True,
                    "customRedirect": redirect_uri,
                    "reconnect": "",
                    "connectionType": "read",
                    "connectionPortalVersion": "v3"
                }
            )
            
            # SnapTrade SDK returns an ApiResponse object
            response_data = response.body if hasattr(response, 'body') else response
            redirect_url = response_data.get('redirectURI') or response_data.get('redirect')
            
            if not redirect_url:
                return {
                    "success": False,
                    "message": "Failed to get redirect URL from SnapTrade"
                }
            
            return {
                "success": True,
                "redirect_uri": redirect_url
            }
        except Exception as e:
            print(f"❌ Error getting login redirect: {str(e)}", flush=True)
            return {
                "success": False,
                "message": f"Failed to get login URL: {str(e)}"
            }
    
    def handle_connection_callback(self, session_id: str) -> Dict[str, Any]:
        """
        Handle the callback after user connects via SnapTrade Portal
        
        Fetches the user's connected accounts and updates session.
        
        Args:
            session_id: User session ID
            
        Returns:
            Dictionary with connection status
        """
        try:
            print(f"🔄 Handling callback for session: {session_id}", flush=True)
            
            # Get session from cache or database
            session = self._get_session(session_id)
            if not session or not session.snaptrade_user_secret:
                print(f"❌ Session not found or no userSecret for: {session_id}", flush=True)
                return {
                    "success": False,
                    "message": "User session not found. Please reconnect.",
                    "is_connected": False
                }
            
            print(f"✅ Found session, fetching accounts...", flush=True)
            
            # Get and parse accounts using helper method
            accounts = self._get_accounts(session_id, session.snaptrade_user_secret)
            
            if not accounts:
                print(f"⚠️ No accounts found after OAuth", flush=True)
                return {
                    "success": False,
                    "message": "No accounts connected. Please try connecting again.",
                    "is_connected": False
                }
            
            # Extract IDs and brokerage names
            account_ids = [acc.id for acc in accounts]
            brokerage_names = list(set(acc.institution_name or 'Unknown' for acc in accounts))
            
            print(f"✅ Connected {len(account_ids)} accounts from: {', '.join(brokerage_names)}", flush=True)
            
            # Update session connection status
            session.is_connected = True
            session.account_ids = account_ids
            session.last_activity = datetime.now().isoformat()
            self._save_session(session_id, session)
            
            return {
                "success": True,
                "message": f"Successfully connected to {', '.join(brokerage_names)}!",
                "is_connected": True,
                "account_count": len(account_ids),
                "brokerages": brokerage_names
            }
        except Exception as e:
            print(f"❌ Error handling connection callback: {str(e)}", flush=True)
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Failed to verify connection: {str(e)}",
                "is_connected": False
            }
    
    def disconnect(self, session_id: str) -> None:
        """Disconnect user session"""
        if session_id in self._sessions:
            del self._sessions[session_id]
    
    def get_portfolio(self, session_id: str) -> Dict[str, Any]:
        """
        Get user's portfolio holdings using SnapTrade
        
        Tool for LLM to fetch portfolio data.
        
        Args:
            session_id: User session ID
            
        Returns:
            Dictionary containing portfolio holdings and summary
        """
        try:
            print(f"🔍 Checking portfolio for session_id: {session_id}", flush=True)
            
            # Get session from cache or database
            session = self._get_session(session_id)
            if not session or not session.is_connected:
                print(f"❌ No active connection found for {session_id}", flush=True)
                return {
                    "success": False,
                    "message": "Not connected to any brokerage. Please connect your account first.",
                    "needs_auth": True
                }
            
            print(f"✅ Active connection found, fetching portfolio...", flush=True)
            
            # Verify connection and get accounts
            try:
                accounts = self._get_accounts(session_id, session.snaptrade_user_secret)
                if not accounts:
                    session.is_connected = False
                    return {
                        "success": False,
                        "message": "Your brokerage connection has expired or been disabled. Please reconnect your account.",
                        "needs_auth": True,
                        "connection_expired": True
                    }
            except Exception as e:
                error_msg = str(e).lower()
                if 'unauthorized' in error_msg or 'invalid' in error_msg or 'expired' in error_msg:
                    session.is_connected = False
                    return {
                        "success": False,
                        "message": "Your brokerage connection has expired. Please reconnect your account.",
                        "needs_auth": True,
                        "connection_expired": True
                    }
                raise
            
            # Update activity
            session.last_activity = datetime.now().isoformat()
            
            # Map accounts by ID for lookup
            account_map = {acc.id: acc for acc in accounts}
            
            # Build Account objects with positions
            accounts_list = []
            syncing_count = 0
            
            for account_id in (session.account_ids or []):
                account_model = account_map.get(account_id) or SnapTradeAccountResponse(
                    id=account_id,
                    name='Unknown Account',
                    number='',
                    institution_name='Unknown'
                )
                
                status = None
                try:
                    positions_list = self._get_positions_for_account(session_id, session.snaptrade_user_secret, account_id)
                except Exception as e:
                    error_str = str(e)
                    print(f"⚠️ Error fetching positions for account {account_id}: {error_str}", flush=True)
                    positions_list = []
                    
                    if '425' in error_str or '3012' in error_str or 'Too Early' in error_str:
                        syncing_count += 1
                        status = 'syncing'
                    else:
                        status = 'error'
                
                # Build Account model
                accounts_list.append(account_model.to_account(
                    positions=positions_list,
                    total_value=sum(pos.value for pos in positions_list),
                    status=status
                ))
            
            # Let Portfolio handle ALL the aggregation!
            portfolio = Portfolio.from_accounts(accounts_list, syncing_count=syncing_count)
            return portfolio.model_dump()
            
        except Exception as e:
            print(f"❌ Error fetching portfolio: {str(e)}", flush=True)
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Error fetching portfolio: {str(e)}"
            }
    
    def has_active_connection(self, session_id: str) -> bool:
        """Check if user has an active connection"""
        session = self._get_session(session_id)
        has_connection = session is not None and session.is_connected
        print(f"🔍 has_active_connection({session_id}): {has_connection}", flush=True)
        return has_connection


# Tool definitions for LiteLLM
SNAPTRADE_TOOL_DEFINITIONS = [
    {
        "type": "function",
        "function": {
            "name": "get_portfolio",
            "description": "Fetch the user's current brokerage portfolio holdings (Robinhood, TD Ameritrade, etc.), including stocks they own, quantities, current prices, and total value. ALWAYS call this tool first when the user asks about their portfolio, stocks, holdings, or account value. This tool will automatically handle authentication - if the user isn't connected, it will tell you to request connection. Do not guess or assume - call this tool to check.",
            "parameters": {
                "type": "object",
                "properties": {},
                "required": []
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "request_brokerage_connection",
            "description": "Request the user to connect their brokerage account via SnapTrade. ONLY use this tool if get_portfolio returns an authentication error. Do NOT call this proactively - always try get_portfolio first.",
            "parameters": {
                "type": "object",
                "properties": {},
                "required": []
            }
        }
    }
]


# Global tools instance
snaptrade_tools = SnapTradeTools()

