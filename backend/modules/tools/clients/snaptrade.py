"""
SnapTrade tools for portfolio management

SECURITY NOTES:
- No credentials are stored or passed through the app
- OAuth authentication is handled by SnapTrade
- Users connect their brokerages securely through SnapTrade's Connection Portal
"""
from snaptrade_client import SnapTrade
from typing import Dict, Any, Optional, List, AsyncGenerator, Union
from datetime import datetime
from pydantic import BaseModel
from config import Config
from database import SessionLocal
from crud import snaptrade_user as snaptrade_crud
from crud import brokerage_account as brokerage_crud
from models.db import SnapTradeUser as DBSnapTradeUser
from models.snaptrade import (
    Position, Account, AggregatedHolding, Portfolio,
    SnapTradePositionResponse, SnapTradeAccountResponse
)
from models.sse import SSEEvent
import asyncio


class SnapTradeSession(BaseModel):
    """
    Session data for a SnapTrade user
    SECURITY: Only stores connection status and user ID, no credentials
    """
    snaptrade_user_id: str
    snaptrade_user_secret: str  # Generated by SnapTrade, needed for API calls
    is_connected: bool
    last_activity: str  # ISO format timestamp
    account_ids: Optional[List[str]] = None
    
    class Config:
        validate_assignment = True


class SnapTradeTools:
    """
    Tools for interacting with SnapTrade API
    
    SECURITY ARCHITECTURE:
    - OAuth flow: Frontend â†’ SnapTrade Portal â†’ Callback â†’ Backend
    - No credentials ever pass through our app
    - SnapTrade manages all authentication and token storage
    - We only store SnapTrade user IDs and connection status
    """
    
    def __init__(self):
        # Initialize SnapTrade client
        self.client = SnapTrade(
            consumer_key=Config.SNAPTRADE_CONSUMER_KEY,
            client_id=Config.SNAPTRADE_CLIENT_ID
        )
        # Cache sessions in memory for performance (but also persist to DB)
        self._sessions: Dict[str, SnapTradeSession] = {}
    
    def _get_session(self, user_id: str) -> Optional[SnapTradeSession]:
        """Get session from cache or database"""
        # Check cache first
        if user_id in self._sessions:
            return self._sessions[user_id]
        
        # Load from database
        db = SessionLocal()
        try:
            db_user = snaptrade_crud.get_user_by_id(db, user_id)
            if db_user and db_user.snaptrade_user_secret:
                # Restore to cache
                session = SnapTradeSession(
                    snaptrade_user_id=db_user.snaptrade_user_id,
                    snaptrade_user_secret=db_user.snaptrade_user_secret,
                    is_connected=db_user.is_connected,
                    last_activity=db_user.last_activity.isoformat(),
                    account_ids=db_user.connected_account_ids.split(',') if db_user.connected_account_ids else []
                )
                self._sessions[user_id] = session
                print(f"âœ… Loaded session from database: {user_id}", flush=True)
                return session
        finally:
            db.close()
        
        return None
    
    def _save_session(self, user_id: str, session: SnapTradeSession):
        """Save session to both cache and database"""
        print(f"ðŸ’¾ Saving session: {user_id}, is_connected={session.is_connected}", flush=True)
        
        # Update cache
        self._sessions[user_id] = session
        
        # Save to database
        db = SessionLocal()
        try:
            db_user = snaptrade_crud.get_user_by_id(db, user_id)
            if db_user:
                # Update existing
                print(f"ðŸ’¾ Updating existing user in DB, setting is_connected={session.is_connected}", flush=True)
                db_user.snaptrade_user_secret = session.snaptrade_user_secret
                db_user.is_connected = session.is_connected
                db_user.connected_account_ids = ','.join(session.account_ids) if session.account_ids else None
                db_user.last_activity = datetime.utcnow()
                db.commit()
                print(f"âœ… Session saved successfully, is_connected={db_user.is_connected}", flush=True)
            else:
                # Create new
                print(f"ðŸ’¾ Creating new user in DB", flush=True)
                snaptrade_crud.create_user(
                    db=db,
                    user_id=user_id,
                    snaptrade_user_id=session.snaptrade_user_id,
                    snaptrade_user_secret=session.snaptrade_user_secret
                )
                if session.is_connected and session.account_ids:
                    print(f"ðŸ’¾ Updating connection status to True", flush=True)
                    snaptrade_crud.update_connection_status(
                        db=db,
                        user_id=user_id,
                        is_connected=True,
                        account_ids=','.join(session.account_ids)
                    )
                print(f"âœ… New user created successfully", flush=True)
        except Exception as e:
            print(f"âŒ Error saving session to database: {e}", flush=True)
            import traceback
            traceback.print_exc()
        finally:
            db.close()
    
    async def _get_accounts(self, user_id: str, user_secret: str) -> List[SnapTradeAccountResponse]:
        """Get user's accounts from SnapTrade and parse with Pydantic"""
        # Run the synchronous API call in executor to avoid blocking
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: self.client.account_information.list_user_accounts(
                user_id=user_id,
                user_secret=user_secret
            )
        )
        accounts_data = response.body if hasattr(response, 'body') else response
        
        # Parse using Pydantic models
        parsed_accounts = []
        for account_data in accounts_data:
            try:
                account = SnapTradeAccountResponse(**account_data) if isinstance(account_data, dict) else account_data
                parsed_accounts.append(account)
            except Exception as e:
                print(f"âš ï¸ Error parsing account: {e}", flush=True)
                continue
        
        return parsed_accounts
    
    async def _get_positions_for_account(self, user_id: str, user_secret: str, account_id: str) -> List[Position]:
        """Get positions for a specific account and parse with Pydantic"""
        # Run the synchronous API call in executor to avoid blocking
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: self.client.account_information.get_user_account_positions(
                user_id=user_id,
                user_secret=user_secret,
                account_id=account_id
            )
        )
        positions_data = response.body if hasattr(response, 'body') else response
        
        # Parse using Pydantic
        parsed_positions = []
        if positions_data:
            for position_data in positions_data:
                try:
                    pos_response = SnapTradePositionResponse(**position_data) if isinstance(position_data, dict) else position_data
                    position = pos_response.to_position()
                    if position.quantity > 0:
                        parsed_positions.append(position)
                except Exception as e:
                    print(f"âš ï¸ Error parsing position: {e}", flush=True)
                    continue
        
        return parsed_positions
    
    def _handle_user_already_exists(self, user_id: str) -> Dict[str, Any]:
        """Handle the case where a SnapTrade user already exists"""
        print(f"âš ï¸ User already exists in SnapTrade, trying to delete and recreate...", flush=True)
        
        # Try to delete the existing user first
        try:
            self.client.authentication.delete_snap_trade_user(user_id=user_id)
            print(f"âœ… Deleted existing SnapTrade user: {user_id}", flush=True)
        except Exception as delete_error:
            print(f"âš ï¸ Could not delete user (might not have permission): {str(delete_error)}", flush=True)
            return {
                "success": False,
                "message": "User conflict detected. Please try again.",
                "requires_new_session": True
            }
        
        # Try registering again after deletion
        try:
            response = self.client.authentication.register_snap_trade_user(
                body={"userId": user_id}
            )
            
            response_data = response.body if hasattr(response, 'body') else response
            snaptrade_user_id = response_data.get('userId') or user_id
            snaptrade_user_secret = response_data.get('userSecret')
            
            if not snaptrade_user_secret:
                raise Exception("No userSecret returned after recreation")
            
            # Store session with new userSecret
            session = SnapTradeSession(
                snaptrade_user_id=snaptrade_user_id,
                snaptrade_user_secret=snaptrade_user_secret,
                is_connected=False,
                last_activity=datetime.now().isoformat()
            )
            self._save_session(user_id, session)
            
            print(f"âœ… Recreated SnapTrade user: {snaptrade_user_id}", flush=True)
            
            return {
                "success": True,
                "snaptrade_user_id": snaptrade_user_id,
                "snaptrade_user_secret": snaptrade_user_secret
            }
        except Exception as recreate_error:
            print(f"âŒ Error recreating user: {str(recreate_error)}", flush=True)
            return {
                "success": False,
                "message": "Session conflict detected. Please refresh the page to create a new session.",
                "requires_new_session": True
            }
    
    def register_user(self, user_id: str) -> Dict[str, Any]:
        """
        Register a new user with SnapTrade
        
        This creates a SnapTrade user ID and receives a userSecret from SnapTrade.
        The userSecret is generated by SnapTrade and must be stored for all future API calls.
        
        Args:
            user_id: Our internal user ID (Supabase UUID, used as SnapTrade userId)
            
        Returns:
            Dictionary with snaptrade_user_id and snaptrade_user_secret
        """
        try:
            # Register user with SnapTrade
            # Using user_id as the userId for consistency
            response = self.client.authentication.register_snap_trade_user(
                body={
                    "userId": user_id
                }
            )
            
            # SnapTrade SDK returns an ApiResponse object, need to access body
            response_data = response.body if hasattr(response, 'body') else response
            
            snaptrade_user_id = response_data.get('userId') or user_id
            snaptrade_user_secret = response_data.get('userSecret')
            
            if not snaptrade_user_secret:
                raise Exception("No userSecret returned from SnapTrade")
            
            # Store session
            session = SnapTradeSession(
                snaptrade_user_id=snaptrade_user_id,
                snaptrade_user_secret=snaptrade_user_secret,
                is_connected=False,
                last_activity=datetime.now().isoformat()
            )
            self._save_session(user_id, session)
            
            print(f"âœ… Registered SnapTrade user and saved to DB: {snaptrade_user_id}", flush=True)
            
            return {
                "success": True,
                "snaptrade_user_id": snaptrade_user_id,
                "snaptrade_user_secret": snaptrade_user_secret
            }
        except Exception as e:
            error_str = str(e)
            print(f"âŒ Error registering user: {error_str}", flush=True)
            
            # Check if user already exists (error code 1010)
            if "already exist" in error_str or "1010" in error_str:
                return self._handle_user_already_exists(user_id)
            
            return {
                "success": False,
                "message": f"Failed to register user: {error_str}"
            }
    
    def get_login_redirect_uri(self, user_id: str, redirect_uri: str) -> Dict[str, Any]:
        """
        Get the SnapTrade Connection Portal URL for OAuth login (shows all brokerages)
        
        This is the legacy method that shows all brokerages. For connecting to a specific
        broker, use get_login_redirect_uri_for_broker() instead.
        
        Args:
            user_id: User ID (Supabase UUID, also used as SnapTrade user_id)
            redirect_uri: Where to redirect after successful connection
            
        Returns:
            Dictionary with redirect URL
        """
        # Use the new method without specifying a broker (shows all)
        return self.get_login_redirect_uri_for_broker(user_id, redirect_uri, broker_id=None)
    
    async def handle_connection_callback(self, user_id: str) -> Dict[str, Any]:
        """
        Handle the callback after user connects via SnapTrade Portal
        
        Fetches the user's connected accounts and updates session.
        
        Args:
            user_id: User ID (Supabase UUID)
            
        Returns:
            Dictionary with connection status
        """
        try:
            print(f"ðŸ”„ Handling callback for user: {user_id}", flush=True)
            
            # Get session from cache or database
            session = self._get_session(user_id)
            if not session or not session.snaptrade_user_secret:
                print(f"âŒ Session not found or no userSecret for: {user_id}", flush=True)
                return {
                    "success": False,
                    "message": "User session not found. Please reconnect.",
                    "is_connected": False
                }
            
            print(f"âœ… Found session, fetching accounts...", flush=True)
            
            # Get and parse accounts using helper method
            accounts = await self._get_accounts(user_id, session.snaptrade_user_secret)
            
            if not accounts:
                print(f"âš ï¸ No accounts found after OAuth", flush=True)
                return {
                    "success": False,
                    "message": "No accounts connected. Please try connecting again.",
                    "is_connected": False
                }
            
            # Extract IDs and brokerage names
            account_ids = [acc.id for acc in accounts]
            brokerage_names = list(set(acc.institution_name or 'Unknown' for acc in accounts))
            
            print(f"âœ… Connected {len(account_ids)} accounts from: {', '.join(brokerage_names)}", flush=True)
            
            # Update session connection status
            session.is_connected = True
            session.account_ids = account_ids
            session.last_activity = datetime.now().isoformat()
            self._save_session(user_id, session)
            
            return {
                "success": True,
                "message": f"Successfully connected to {', '.join(brokerage_names)}!",
                "is_connected": True,
                "account_count": len(account_ids),
                "brokerages": brokerage_names
            }
        except Exception as e:
            error_str = str(e)
            print(f"âŒ Error handling connection callback: {error_str}", flush=True)
            import traceback
            traceback.print_exc()
            
            # Check if it's an invalid credentials error
            if '401' in error_str or '1083' in error_str or 'Invalid userID or userSecret' in error_str:
                print(f"âš ï¸ Invalid credentials detected during callback", flush=True)
                # Delete the old database record
                db = SessionLocal()
                try:
                    from crud import snaptrade_user as snaptrade_crud
                    snaptrade_crud.delete_user(db, user_id)
                finally:
                    db.close()
                
                # Clear from cache
                if user_id in self._sessions:
                    del self._sessions[user_id]
                
                return {
                    "success": False,
                    "message": "Your credentials were invalid (possibly due to API key change). Please reconnect to create a new session.",
                    "is_connected": False,
                    "requires_new_connection": True
                }
            
            return {
                "success": False,
                "message": f"Failed to verify connection: {error_str}",
                "is_connected": False
            }
    
    def disconnect(self, user_id: str) -> None:
        """Disconnect user session"""
        if user_id in self._sessions:
            del self._sessions[user_id]
    
    async def get_connected_accounts(self, user_id: str) -> Dict[str, Any]:
        """
        Get list of user's connected brokerage accounts with details
        
        Args:
            user_id: User ID (Supabase UUID)
            
        Returns:
            Dictionary with list of connected accounts
        """
        try:
            session = self._get_session(user_id)
            if not session or not session.is_connected:
                return {
                    "success": True,
                    "accounts": [],
                    "message": "No connected accounts"
                }
            
            # Get accounts from SnapTrade
            accounts = await self._get_accounts(user_id, session.snaptrade_user_secret)
            
            # Format account details
            account_list = []
            for acc in accounts:
                account_list.append({
                    "id": acc.id,
                    "name": acc.name or "Unknown Account",
                    "number": acc.number or "",
                    "institution": acc.institution_name or "Unknown",
                    "type": acc.get_account_type(),
                    "balance": acc.get_balance()
                })
            
            return {
                "success": True,
                "accounts": account_list,
                "message": f"Found {len(account_list)} connected account(s)"
            }
        except Exception as e:
            print(f"âŒ Error getting connected accounts: {str(e)}", flush=True)
            return {
                "success": False,
                "accounts": [],
                "message": f"Error fetching accounts: {str(e)}"
            }
    
    def get_available_brokerages(self) -> Dict[str, Any]:
        """
        Get list of available brokerages that can be connected
        
        Returns:
            Dictionary with list of supported brokerages
        """
        # List of major brokerages supported by SnapTrade
        # This is a curated list of the most popular ones
        brokerages = [
            {"id": "ROBINHOOD", "name": "Robinhood", "logo": "ðŸ¹"},
            {"id": "ALPACA", "name": "Alpaca", "logo": "ðŸ¦™"},
            {"id": "TRADIER", "name": "Tradier", "logo": "ðŸ“Š"},
            {"id": "QUESTRADE", "name": "Questrade", "logo": "ðŸ"},
            {"id": "INTERACTIVE_BROKERS", "name": "Interactive Brokers", "logo": "ðŸŒ"},
            {"id": "TD", "name": "TD Ameritrade", "logo": "ðŸ¦"},
            {"id": "SCHWAB", "name": "Charles Schwab", "logo": "ðŸ’¼"},
            {"id": "ETRADE", "name": "E*TRADE", "logo": "ðŸ“ˆ"},
            {"id": "FIDELITY", "name": "Fidelity", "logo": "ðŸ›ï¸"},
            {"id": "WEBULL", "name": "Webull", "logo": "ðŸ‚"},
            {"id": "MOOMOO", "name": "Moomoo", "logo": "ðŸ„"},
            {"id": "WEALTHSIMPLE", "name": "Wealthsimple", "logo": "ðŸ‡¨ðŸ‡¦"},
        ]
        
        return {
            "success": True,
            "brokerages": brokerages,
            "message": f"{len(brokerages)} brokerages available"
        }
    
    def get_login_redirect_uri_for_broker(self, user_id: str, redirect_uri: str, broker_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Get the SnapTrade Connection Portal URL for OAuth login for a specific broker
        
        Args:
            user_id: User ID (Supabase UUID, also used as SnapTrade user_id)
            redirect_uri: Where to redirect after successful connection
            broker_id: Optional broker ID (e.g., "ROBINHOOD", "ALPACA"). If None, shows all brokers
            
        Returns:
            Dictionary with redirect URL
        """
        print(f"ðŸŒ get_login_redirect_uri_for_broker called with broker: {broker_id}, redirect_uri: {redirect_uri}", flush=True)
        try:
            # Get or load session
            session = self._get_session(user_id)
            
            # If no session exists, register user
            if not session:
                register_result = self.register_user(user_id)
                if not register_result["success"]:
                    return register_result
                session = self._get_session(user_id)
            if not session or not session.snaptrade_user_secret:
                return {
                    "success": False,
                    "message": "User not registered properly. Please try again."
                }
            
            # Build request body
            body = {
                "immediateRedirect": True,
                "customRedirect": redirect_uri,
                "reconnect": "",
                "connectionType": "read",
                "connectionPortalVersion": "v3"
            }
            
            # Add broker if specified
            if broker_id:
                body["broker"] = broker_id
            
            # Get login redirect URI from SnapTrade
            print(f"ðŸ“¡ Calling SnapTrade API with broker={broker_id}, customRedirect: {redirect_uri}", flush=True)
            response = self.client.authentication.login_snap_trade_user(
                user_id=user_id,
                user_secret=session.snaptrade_user_secret,
                body=body
            )
            
            # SnapTrade SDK returns an ApiResponse object
            response_data = response.body if hasattr(response, 'body') else response
            redirect_url = response_data.get('redirectURI') or response_data.get('redirect')
            
            print(f"ðŸ“¡ SnapTrade returned redirect URL: {redirect_url}", flush=True)
            
            if not redirect_url:
                return {
                    "success": False,
                    "message": "Failed to get redirect URL from SnapTrade"
                }
            
            return {
                "success": True,
                "redirect_uri": redirect_url,
                "broker_id": broker_id
            }
        except Exception as e:
            error_str = str(e)
            print(f"âŒ Error getting login redirect: {error_str}", flush=True)
            
            # Check if it's an invalid credentials error (401 or code 1083)
            if '401' in error_str or '1083' in error_str or 'Invalid userID or userSecret' in error_str:
                print(f"âš ï¸ Invalid credentials detected, clearing old session and re-registering...", flush=True)
                
                # Delete the old database record
                db = SessionLocal()
                try:
                    from crud import snaptrade_user as snaptrade_crud
                    snaptrade_crud.delete_user(db, user_id)
                    print(f"âœ… Deleted old SnapTrade user from database", flush=True)
                finally:
                    db.close()
                
                # Clear from cache
                if user_id in self._sessions:
                    del self._sessions[user_id]
                
                # Try to delete from SnapTrade API (may fail, that's okay)
                try:
                    self.client.authentication.delete_snap_trade_user(user_id=user_id)
                    print(f"âœ… Deleted old SnapTrade user from API", flush=True)
                except Exception as delete_error:
                    print(f"âš ï¸ Could not delete from SnapTrade API: {str(delete_error)}", flush=True)
                
                # Re-register with new credentials
                print(f"ðŸ”„ Re-registering user with new API credentials...", flush=True)
                register_result = self.register_user(user_id)
                if not register_result["success"]:
                    return {
                        "success": False,
                        "message": "Credentials were invalid. Failed to re-register. Please try again."
                    }
                
                # Retry getting the login URL with new credentials
                session = self._get_session(user_id)
                if not session or not session.snaptrade_user_secret:
                    return {
                        "success": False,
                        "message": "Failed to re-register. Please try again."
                    }
                
                try:
                    body = {
                        "immediateRedirect": True,
                        "customRedirect": redirect_uri,
                        "reconnect": "",
                        "connectionType": "read",
                        "connectionPortalVersion": "v3"
                    }
                    if broker_id:
                        body["broker"] = broker_id
                    
                    print(f"ðŸ“¡ Retry: Calling SnapTrade API with broker={broker_id}", flush=True)
                    response = self.client.authentication.login_snap_trade_user(
                        user_id=user_id,
                        user_secret=session.snaptrade_user_secret,
                        body=body
                    )
                    
                    response_data = response.body if hasattr(response, 'body') else response
                    redirect_url = response_data.get('redirectURI') or response_data.get('redirect')
                    
                    print(f"ðŸ“¡ Retry: SnapTrade returned redirect URL: {redirect_url}", flush=True)
                    
                    if not redirect_url:
                        return {
                            "success": False,
                            "message": "Failed to get redirect URL after re-registration"
                        }
                    
                    print(f"âœ… Successfully re-registered and got login URL", flush=True)
                    return {
                        "success": True,
                        "redirect_uri": redirect_url,
                        "broker_id": broker_id
                    }
                except Exception as retry_error:
                    print(f"âŒ Error after re-registration: {str(retry_error)}", flush=True)
                    return {
                        "success": False,
                        "message": f"Re-registered but failed to get login URL: {str(retry_error)}"
                    }
            
            return {
                "success": False,
                "message": f"Failed to get login URL: {error_str}"
            }
    
    async def disconnect_account(self, user_id: str, account_id: str) -> Dict[str, Any]:
        """
        Disconnect a specific brokerage account
        
        Args:
            user_id: User ID (Supabase UUID)
            account_id: SnapTrade account ID to disconnect
            
        Returns:
            Dictionary with success status
        """
        try:
            session = self._get_session(user_id)
            if not session:
                return {
                    "success": False,
                    "message": "No active session found"
                }
            
            # Call SnapTrade API to delete the authorization
            try:
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(
                    None,
                    lambda: self.client.account_information.delete_user_account(
                        user_id=user_id,
                        user_secret=session.snaptrade_user_secret,
                        account_id=account_id
                    )
                )
                print(f"âœ… Deleted account from SnapTrade API: {account_id}", flush=True)
            except Exception as api_error:
                print(f"âš ï¸ Error calling SnapTrade API (continuing anyway): {str(api_error)}", flush=True)
            
            # Update database: mark account as disconnected
            db = SessionLocal()
            try:
                success = brokerage_crud.disconnect_account(db, user_id, account_id)
                if success:
                    print(f"âœ… Marked account as disconnected in DB: {account_id}", flush=True)
                else:
                    print(f"âš ï¸ Account not found in DB: {account_id}", flush=True)
            finally:
                db.close()
            
            # Update session: remove this account from the list
            if session.account_ids and account_id in session.account_ids:
                session.account_ids.remove(account_id)
                
                # If no accounts left, mark as not connected
                if not session.account_ids:
                    session.is_connected = False
                
                self._save_session(user_id, session)
            
            print(f"âœ… Disconnected account {account_id}", flush=True)
            return {
                "success": True,
                "message": "Account disconnected successfully"
            }
        except Exception as e:
            error_str = str(e)
            print(f"âŒ Error disconnecting account: {error_str}", flush=True)
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Failed to disconnect account: {error_str}"
            }
    
    def get_portfolio(self, user_id: str) -> Dict[str, Any]:
        """
        Get user's portfolio holdings using SnapTrade
        
        Tool for LLM to fetch portfolio data.
        
        Args:
            user_id: User ID (Supabase UUID)
            
        Returns:
            Dictionary containing portfolio holdings and summary
        """
        try:
            print(f"ðŸ” Checking portfolio for user_id: {user_id}", flush=True)
            
            # Get session from cache or database
            session = self._get_session(user_id)
            if not session or not session.is_connected:
                print(f"âŒ No active connection found for {user_id}", flush=True)
                return {
                    "success": False,
                    "message": "Not connected to any brokerage. Please connect your account first.",
                    "needs_auth": True
                }
            
            print(f"âœ… Active connection found, fetching portfolio...", flush=True)
            
            # Verify connection and get accounts
            try:
                accounts = self._get_accounts(user_id, session.snaptrade_user_secret)
                if not accounts:
                    session.is_connected = False
                    return {
                        "success": False,
                        "message": "Your brokerage connection has expired or been disabled. Please reconnect your account.",
                        "needs_auth": True,
                        "connection_expired": True
                    }
            except Exception as e:
                error_str = str(e)
                error_msg = error_str.lower()
                
                # Check if it's an invalid credentials error (API key change)
                if '401' in error_str or '1083' in error_str or 'Invalid userID or userSecret' in error_str:
                    print(f"âš ï¸ Invalid credentials detected in get_portfolio, cleaning up...", flush=True)
                    # Delete the old database record
                    db = SessionLocal()
                    try:
                        from crud import snaptrade_user as snaptrade_crud
                        snaptrade_crud.delete_user(db, user_id)
                    finally:
                        db.close()
                    
                    # Clear from cache
                    if user_id in self._sessions:
                        del self._sessions[user_id]
                    
                    return {
                        "success": False,
                        "message": "Your credentials were invalid (possibly due to API key change). Please reconnect to create a new session.",
                        "needs_auth": True,
                        "connection_expired": True
                    }
                elif 'unauthorized' in error_msg or 'invalid' in error_msg or 'expired' in error_msg:
                    session.is_connected = False
                    return {
                        "success": False,
                        "message": "Your brokerage connection has expired. Please reconnect your account.",
                        "needs_auth": True,
                        "connection_expired": True
                    }
                raise
            
            # Update activity
            session.last_activity = datetime.now().isoformat()
            
            # Map accounts by ID for lookup
            account_map = {acc.id: acc for acc in accounts}
            
            # Build Account objects with positions
            accounts_list = []
            syncing_count = 0
            
            for account_id in (session.account_ids or []):
                account_model = account_map.get(account_id) or SnapTradeAccountResponse(
                    id=account_id,
                    name='Unknown Account',
                    number='',
                    institution_name='Unknown'
                )
                
                status = None
                try:
                    positions_list = self._get_positions_for_account(user_id, session.snaptrade_user_secret, account_id)
                except Exception as e:
                    error_str = str(e)
                    print(f"âš ï¸ Error fetching positions for account {account_id}: {error_str}", flush=True)
                    positions_list = []
                    
                    if '425' in error_str or '3012' in error_str or 'Too Early' in error_str:
                        syncing_count += 1
                        status = 'syncing'
                    else:
                        status = 'error'
                
                # Build Account model
                accounts_list.append(account_model.to_account(
                    positions=positions_list,
                    total_value=sum(pos.value for pos in positions_list),
                    status=status
                ))
            
            # Let Portfolio handle ALL the aggregation!
            portfolio = Portfolio.from_accounts(accounts_list, syncing_count=syncing_count)
            return portfolio.to_csv_format()
            
        except Exception as e:
            print(f"âŒ Error fetching portfolio: {str(e)}", flush=True)
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Error fetching portfolio: {str(e)}"
            }
    
    def has_active_connection(self, user_id: str) -> bool:
        """Check if user has an active connection"""
        session = self._get_session(user_id)
        has_connection = session is not None and session.is_connected
        print(f"ðŸ” has_active_connection({user_id}): {has_connection}", flush=True)
        return has_connection
    
    async def get_portfolio_streaming(self, user_id: str) -> AsyncGenerator[Union[SSEEvent, Dict[str, Any]], None]:
        """
        Streaming version of get_portfolio that yields SSE events
        
        Args:
            user_id: User ID (Supabase UUID)
            
        Yields:
            SSEEvent objects followed by final result dict
        """
        # Yield status event
        yield SSEEvent(
            event="tool_status",
            data={
                "status": "fetching",
                "message": "Connecting to brokerage..."
            }
        )
        
        # Call sync method in executor to avoid blocking
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(None, self.get_portfolio, user_id)
        
        # Yield success event
        if result.get("success"):
            total_value = result.get("data", {}).get("total_value", 0)
            num_accounts = len(result.get("data", {}).get("accounts", []))
            yield SSEEvent(
                event="tool_log",
                data={
                    "level": "info",
                    "message": f"âœ“ Retrieved portfolio: {num_accounts} account(s), ${total_value:,.2f} total value"
                }
            )
        
        # Yield final result
        yield result


# Tool definitions for LiteLLM
SNAPTRADE_TOOL_DEFINITIONS = [
    {
        "type": "function",
        "function": {
            "name": "get_portfolio",
            "description": "Fetch the user's current brokerage portfolio holdings (Robinhood, TD Ameritrade, etc.), including stocks they own, quantities, current prices, and total value. Returns data in efficient CSV format: holdings_csv contains all unique positions aggregated across accounts. ALWAYS call this tool first when the user asks about their portfolio, stocks, holdings, or account value. This tool will automatically handle authentication - if the user isn't connected, it will tell you to request connection. Do not guess or assume - call this tool to check.",
            "parameters": {
                "type": "object",
                "properties": {},
                "required": []
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "request_brokerage_connection",
            "description": "Request the user to connect their brokerage account via SnapTrade. ONLY use this tool if get_portfolio returns an authentication error. Do NOT call this proactively - always try get_portfolio first.",
            "parameters": {
                "type": "object",
                "properties": {},
                "required": []
            }
        }
    }
]


# Global tools instance
snaptrade_tools = SnapTradeTools()

